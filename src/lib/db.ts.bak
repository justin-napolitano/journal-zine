// lib/db.ts
  return (
    <div className="main-shell">
      {/* Header */}
      <div className="page-head">
        <div>
          <div className="site-heading">journal</div>
          <div className="site-subtitle">
            an ongoing stream of photos &amp; fragments
          </div>
        </div>

        {!isAuthed && (
          <Link
            href="/login"
            style={{
              fontSize: "0.75rem",
              textTransform: "uppercase",
              letterSpacing: "0.08em",
              color: "var(--muted)",
            }}
          >
            log in
          </Link>
        )}
      </div>

      {/* Centered column for search + composer + feed */}
      <div className="journal-column">
        {/* Single search bar */}
        <div className="journal-search">
          <form
            className="journal-search-form"
            onSubmit={handleSearchSubmit}
          >
            <div className="journal-search-row">
              <input
                className="journal-search-input"
                type="text"
                placeholder='search… (try "tag:journal", "type:photos", "source:mastodon")'
                value={search}
                onChange={(e) => setSearch(e.target.value)}
              />
              <button
                className="journal-search-button"
                type="submit"
                disabled={loadingInitial}
              >
                {loadingInitial ? "…" : "Search"}
              </button>
            </div>
import { sql } from '@vercel/postgres';

export type Post = {
  id: number;
  created_at: string;
  kind: 'text' | 'photo';
  body: string;
  image_data: string | null;
  // NEW FIELDS for external sources (Mastodon, etc.)
  source: "local" | "mastodon" | string;
  external_id: string | null;
  external_url: string | null;
  source_deleted: boolean;
  // NEW
  link_url: string | null;
};

export async function initDb() {
  // Safe to call more than once; it’s idempotent.
  await sql`
    CREATE TABLE IF NOT EXISTS posts (
      id SERIAL PRIMARY KEY,
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      kind TEXT NOT NULL CHECK (kind IN ('text', 'photo')),
      body TEXT NOT NULL CHECK (char_length(body) <= 500),
      image_data TEXT
    );
  `;
  await sql`
    CREATE INDEX IF NOT EXISTS idx_posts_created_at
    ON posts (created_at DESC);
  `;
}

export type PostFilters = {
  source?: string; // "local" | "mastodon" | etc | "all"
  kind?: "text" | "photo" | "link" | "all";
  tag?: string;    // without '#'
  q?: string;      // free-text search
};

export async function fetchPostsPage(
  cursor: number | null,
  limit: number,
  filters: PostFilters = {},
): Promise<Post[]> {
  const hasSource = !!filters.source && filters.source !== "all";
  const hasKind =
    !!filters.kind &&
    filters.kind !== "all" &&
    (filters.kind === "text" ||
      filters.kind === "photo" ||
      filters.kind === "link");

  const hasTag = !!(filters.tag && filters.tag.trim() !== "");
  const hasQ = !!(filters.q && filters.q.trim() !== "");

  const tagPattern =
    "%" +
    "#" +
    (filters.tag ? filters.tag.trim().replace(/^#/, "") : "") +
    "%";

  const qPattern = "%" + (filters.q ? filters.q.trim() : "") + "%";

  const { rows } = await sql<Post>`
    SELECT *
    FROM posts
    WHERE
      (${cursor === null} OR id < ${cursor}) AND
      (${!hasSource} OR source = ${filters.source}) AND
      (${!hasKind} OR kind = ${filters.kind}) AND
      (${!hasTag} OR body ILIKE ${tagPattern}) AND
      (${
        !hasQ
      } OR (
        body ILIKE ${qPattern}
        OR COALESCE(link_url, '') ILIKE ${qPattern}
        OR source ILIKE ${qPattern}
        OR kind ILIKE ${qPattern}
      ))
    ORDER BY id DESC
    LIMIT ${limit}
  `;

  return rows;
}

